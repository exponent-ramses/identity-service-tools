import type { Client } from "@microsoft/microsoft-graph-client";
import type {
  EntraUser,
  CreateUserInput,
  UpdateUserInput,
  PasswordResetInput,
  OperationResult,
  PagedResult,
  EntraSDKConfig,
} from "./types/index.js";

/**
 * User management operations against Microsoft Graph API.
 *
 * All methods operate on Entra External ID local accounts using
 * the "userName" identity sign-in type.
 */
export class UserOperations {
  constructor(
    private client: Client,
    private config: EntraSDKConfig
  ) {}

  // ── Lookup ──────────────────────────────────────────────────

  /**
   * Find a user by their Entra object ID.
   */
  async getById(userId: string): Promise<OperationResult<EntraUser>> {
    try {
      const user = await this.client
        .api(`/users/${userId}`)
        .select(USER_SELECT_FIELDS)
        .get();

      return { success: true, data: user as EntraUser };
    } catch (err) {
      return this.handleError(err, "getById");
    }
  }

  /**
   * Find a user by their username (sign-in name identity).
   *
   * This searches the `identities` collection for a local account
   * with signInType "userName" matching the given value.
   */
  async getByUsername(username: string): Promise<OperationResult<EntraUser>> {
    try {
      const filter = `identities/any(id:id/issuer eq '${this.config.issuerDomain}' and id/issuerAssignedId eq '${username}' and id/signInType eq 'userName')`;

      const result = await this.client
        .api("/users")
        .filter(filter)
        .select(USER_SELECT_FIELDS)
        .get();

      const users = result.value as EntraUser[];
      if (users.length === 0) {
        return {
          success: false,
          error: {
            code: "UserNotFound",
            message: `No user found with username: ${username}`,
          },
        };
      }

      return { success: true, data: users[0] };
    } catch (err) {
      return this.handleError(err, "getByUsername");
    }
  }

  /**
   * Search users by display name, username, or email.
   * Supports partial matching for display name search.
   */
  async search(
    query: string,
    options: { top?: number; nextLink?: string } = {}
  ): Promise<OperationResult<PagedResult<EntraUser>>> {
    try {
      const top = options.top ?? 25;

      let request;
      if (options.nextLink) {
        request = this.client.api(options.nextLink);
      } else {
        // Use $filter with startsWith for displayName, or exact match for identities
        // Graph API doesn't support 'contains' on displayName without ConsistencyLevel/search
        // We use ConsistencyLevel: eventual + $search for flexible matching
        request = this.client
          .api("/users")
          .header("ConsistencyLevel", "eventual")
          .search(`"displayName:${query}" OR "mail:${query}" OR "userPrincipalName:${query}"`)
          .select(USER_SELECT_FIELDS)
          .top(top)
          .orderby("displayName");
      }

      const result = await request.get();
      const items = result.value as EntraUser[];

      return {
        success: true,
        data: {
          items,
          nextLink: result["@odata.nextLink"],
          totalCount: result["@odata.count"],
        },
      };
    } catch (err) {
      return this.handleError(err, "search");
    }
  }

  /**
   * List users with pagination support.
   */
  async list(
    options: { top?: number; nextLink?: string; filter?: string } = {}
  ): Promise<OperationResult<PagedResult<EntraUser>>> {
    try {
      const top = options.top ?? 25;

      let request;
      if (options.nextLink) {
        request = this.client.api(options.nextLink);
      } else {
        request = this.client
          .api("/users")
          .select(USER_SELECT_FIELDS)
          .top(top)
          .orderby("displayName");

        if (options.filter) {
          request = request.filter(options.filter);
        }
      }

      const result = await request.get();
      const items = result.value as EntraUser[];

      return {
        success: true,
        data: {
          items,
          nextLink: result["@odata.nextLink"],
        },
      };
    } catch (err) {
      return this.handleError(err, "list");
    }
  }

  // ── Create ──────────────────────────────────────────────────

  /**
   * Create a new local account user in Entra External ID.
   *
   * Sets up the user with a username identity and optionally an email identity.
   * If no email is provided, a shadow email can be generated by the caller.
   */
  async create(input: CreateUserInput): Promise<OperationResult<EntraUser>> {
    try {
      const identities = [
        {
          signInType: "userName",
          issuer: this.config.issuerDomain,
          issuerAssignedId: input.username,
        },
      ];

      if (input.email) {
        identities.push({
          signInType: "emailAddress",
          issuer: this.config.issuerDomain,
          issuerAssignedId: input.email,
        });
      }

      const body: Record<string, unknown> = {
        displayName: input.displayName,
        identities,
        passwordProfile: {
          password: input.password,
          forceChangePasswordNextSignIn: input.forceChangePassword ?? true,
        },
        passwordPolicies: "DisablePasswordExpiration",
      };

      if (input.email) body.mail = input.email;
      if (input.mobilePhone) body.mobilePhone = input.mobilePhone;
      if (input.companyName) body.companyName = input.companyName;
      if (input.jobTitle) body.jobTitle = input.jobTitle;
      if (input.department) body.department = input.department;

      const user = await this.client.api("/users").post(body);

      return { success: true, data: user as EntraUser };
    } catch (err) {
      return this.handleError(err, "create");
    }
  }

  // ── Update ──────────────────────────────────────────────────

  /**
   * Update user profile properties.
   */
  async update(
    userId: string,
    input: UpdateUserInput
  ): Promise<OperationResult> {
    try {
      await this.client.api(`/users/${userId}`).patch(input);
      return { success: true };
    } catch (err) {
      return this.handleError(err, "update");
    }
  }

  // ── Password Management ────────────────────────────────────

  /**
   * Reset a user's password. Optionally force them to change it on next sign-in.
   */
  async resetPassword(input: PasswordResetInput): Promise<OperationResult> {
    try {
      await this.client.api(`/users/${input.userId}`).patch({
        passwordProfile: {
          password: input.newPassword,
          forceChangePasswordNextSignIn: input.forceChangeOnNextSignIn ?? true,
        },
      });
      return { success: true };
    } catch (err) {
      return this.handleError(err, "resetPassword");
    }
  }

  // ── Account Enable/Disable ─────────────────────────────────

  /**
   * Disable a user account. This immediately blocks sign-in.
   */
  async disable(userId: string): Promise<OperationResult> {
    try {
      await this.client.api(`/users/${userId}`).patch({
        accountEnabled: false,
      });
      return { success: true };
    } catch (err) {
      return this.handleError(err, "disable");
    }
  }

  /**
   * Re-enable a previously disabled user account.
   */
  async enable(userId: string): Promise<OperationResult> {
    try {
      await this.client.api(`/users/${userId}`).patch({
        accountEnabled: true,
      });
      return { success: true };
    } catch (err) {
      return this.handleError(err, "enable");
    }
  }

  // ── Soft Delete (Deactivate) ───────────────────────────────

  /**
   * Soft-delete a user by disabling their account and moving them
   * to the "Deactivated Users" security group.
   *
   * This pattern revokes all Conditional Access grants while keeping
   * the account recoverable. True deletion goes through Entra's
   * recycle bin (30-day soft delete).
   */
  async deactivate(userId: string): Promise<OperationResult> {
    try {
      // Disable the account first
      await this.client.api(`/users/${userId}`).patch({
        accountEnabled: false,
      });

      // Add to deactivated group if configured
      if (this.config.deactivatedGroupId) {
        await this.client
          .api(`/groups/${this.config.deactivatedGroupId}/members/$ref`)
          .post({
            "@odata.id": `https://graph.microsoft.com/v1.0/users/${userId}`,
          });
      }

      return { success: true };
    } catch (err) {
      return this.handleError(err, "deactivate");
    }
  }

  /**
   * Reactivate a previously deactivated user — re-enable account
   * and remove from deactivated group.
   */
  async reactivate(userId: string): Promise<OperationResult> {
    try {
      // Re-enable the account
      await this.client.api(`/users/${userId}`).patch({
        accountEnabled: true,
      });

      // Remove from deactivated group if configured
      if (this.config.deactivatedGroupId) {
        await this.client
          .api(
            `/groups/${this.config.deactivatedGroupId}/members/${userId}/$ref`
          )
          .delete();
      }

      return { success: true };
    } catch (err) {
      return this.handleError(err, "reactivate");
    }
  }

  // ── Delete ─────────────────────────────────────────────────

  /**
   * Delete a user. This is a soft delete in Entra — the user goes
   * to the recycle bin for 30 days before permanent deletion.
   *
   * Prefer `deactivate()` for most support workflows.
   */
  async delete(userId: string): Promise<OperationResult> {
    try {
      await this.client.api(`/users/${userId}`).delete();
      return { success: true };
    } catch (err) {
      return this.handleError(err, "delete");
    }
  }

  // ── Group Membership ───────────────────────────────────────

  /**
   * Get all groups a user belongs to.
   */
  async getGroups(
    userId: string
  ): Promise<OperationResult<{ id: string; displayName: string }[]>> {
    try {
      const result = await this.client
        .api(`/users/${userId}/memberOf`)
        .select("id,displayName")
        .get();

      return { success: true, data: result.value };
    } catch (err) {
      return this.handleError(err, "getGroups");
    }
  }

  // ── Helpers ────────────────────────────────────────────────

  private handleError(err: unknown, operation: string): OperationResult<never> {
    const graphError = err as {
      statusCode?: number;
      code?: string;
      message?: string;
      body?: string;
    };

    let code = graphError.code ?? "Unknown";
    let message = graphError.message ?? "An unknown error occurred";

    // Try to parse the body for more detail
    if (graphError.body) {
      try {
        const body = JSON.parse(graphError.body);
        code = body.error?.code ?? code;
        message = body.error?.message ?? message;
      } catch {
        // body wasn't JSON, use what we have
      }
    }

    console.error(`[EntraSDK] ${operation} failed:`, { code, message });

    return {
      success: false,
      error: { code, message, details: graphError },
    };
  }
}

const USER_SELECT_FIELDS = [
  "id",
  "displayName",
  "userPrincipalName",
  "mail",
  "accountEnabled",
  "createdDateTime",
  "identities",
  "jobTitle",
  "department",
  "companyName",
  "mobilePhone",
  "signInActivity",
].join(",");
